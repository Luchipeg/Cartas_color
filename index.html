<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chroma Order</title>

<style>
body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  background: #f2f2f2;
}

header {
  background: #111;
  color: white;
  padding: 10px;
  text-align: center;
}

main { padding: 10px; }

select, input, button {
  margin-bottom: 6px;
  padding: 6px;
}

canvas {
  width: 100%;
  border-radius: 8px;
  background: #000;
  touch-action: none;
}

#canvasWrapper { position: relative; }

#loupe {
  position: absolute;
  width: 100px;
  height: 100px;
  border-radius: 50%;
  border: 3px solid white;
  overflow: hidden;
  pointer-events: none;
  display: none;
}

#loupe canvas { width: 100%; height: 100%; }

#pickerBox {
  position: absolute;
  background: white;
  border-radius: 10px;
  padding: 8px;
  width: 170px;
  box-shadow: 0 6px 20px rgba(0,0,0,.25);
  display: none;
}

#colorPreview {
  height: 28px;
  border-radius: 6px;
  margin-bottom: 6px;
  border: 1px solid #ccc;
}

.grid {
  display: grid;
  grid-template-columns: repeat(10, 1fr);
  gap: 6px;
  margin-top: 10px;
}

.colorCell {
  background: white;
  border-radius: 6px;
  padding: 4px;
  text-align: center;
  font-size: 11px;
  position: relative;
}

.colorSwatch {
  height: 30px;
  border-radius: 4px;
}

.removeBtn {
  position: absolute;
  top: 2px;
  right: 4px;
  cursor: pointer;
  color: red;
}
</style>
</head>

<body>

<header>
  <h2>Chroma Order</h2>
</header>

<main>

<select id="collectionSelect"></select>
<button onclick="addCollection()">+ Colección</button><br>

<input type="file" id="imageInput" accept="image/*"><br><br>

<!-- Botones de calibración -->
<button onclick="calibrateBlack()">Calibrar negro</button>
<button onclick="calibrateWhite()">Calibrar blanco</button><br><br>

<div id="canvasWrapper">
  <canvas id="imageCanvas"></canvas>

  <div id="loupe">
    <canvas id="loupeCanvas" width="100" height="100"></canvas>
  </div>

  <div id="pickerBox">
    <div id="colorPreview"></div>
    <input id="colorNumber" placeholder="Número">
    <input id="colorName" placeholder="Nombre">
    <button onclick="saveColor()">Guardar</button>
  </div>
</div>

<br>
<button onclick="sortBy('h')">Ordenar por matiz</button>
<button onclick="sortBy('s')">Ordenar por saturación</button>
<button onclick="sortBy('l')">Ordenar por luminosidad</button>
<button onclick="exportNumbers()">Exportar números</button>

<div class="grid" id="colorGrid"></div>

</main>

<script>
/* ========= DATA ========= */
let data = JSON.parse(localStorage.getItem('chromaData')) || {};
let currentCollection = null;

/* ========= COLLECTIONS ========= */
function refreshCollections() {
  const sel = document.getElementById('collectionSelect');
  sel.innerHTML = '';
  Object.keys(data).forEach(name => {
    const o = document.createElement('option');
    o.value = name; o.textContent = name;
    sel.appendChild(o);
  });
  sel.onchange = () => {
    currentCollection = sel.value;
    renderGrid();
  };
  if (!currentCollection && sel.options.length) {
    currentCollection = sel.options[0].value;
  }
  sel.value = currentCollection;
}

function addCollection() {
  const name = prompt('Nombre de la colección');
  if (!name) return;
  data[name] = [];
  currentCollection = name;
  saveData();
  refreshCollections();
}

/* ========= CANVAS ========= */
const canvas = document.getElementById('imageCanvas');
const ctx = canvas.getContext('2d');
const loupe = document.getElementById('loupe');
const loupeCanvas = document.getElementById('loupeCanvas');
const loupeCtx = loupeCanvas.getContext('2d');
const pickerBox = document.getElementById('pickerBox');
const colorPreview = document.getElementById('colorPreview');

let img = new Image();
let currentColor = null;
let blackPoint = null;
let whitePoint = null;

document.getElementById('imageInput').onchange = e => {
  img.src = URL.createObjectURL(e.target.files[0]);
};

img.onload = () => {
  canvas.width = img.width;
  canvas.height = img.height;
  ctx.drawImage(img,0,0);
  // Reset calibración al cargar nueva imagen
  blackPoint = null;
  whitePoint = null;
};

/* Calibración */
function calibrateBlack() {
  alert('Toca en la imagen el punto negro de referencia');
  canvas.addEventListener('click', pickBlack, { once: true });
}
function calibrateWhite() {
  alert('Toca en la imagen el punto blanco de referencia');
  canvas.addEventListener('click', pickWhite, { once: true });
}
function pickBlack(e) {
  const pos = getPos(e);
  const px = ctx.getImageData(pos.x,pos.y,1,1).data;
  blackPoint = { r:px[0], g:px[1], b:px[2] };
  alert('Negro calibrado');
}
function pickWhite(e) {
  const pos = getPos(e);
  const px = ctx.getImageData(pos.x,pos.y,1,1).data;
  whitePoint = { r:px[0], g:px[1], b:px[2] };
  alert('Blanco calibrado');
}

/* ========= TOUCH ========= */
function getPos(t) {
  const r = canvas.getBoundingClientRect();
  return {
    x: Math.round((t.clientX - r.left) * (canvas.width / r.width)),
    y: Math.round((t.clientY - r.top) * (canvas.height / r.height)),
    sx: t.clientX - r.left,
    sy: t.clientY - r.top
  };
}

canvas.addEventListener('touchstart', e => handleTouch(e.touches[0]));
canvas.addEventListener('touchmove', e => handleTouch(e.touches[0]));

function handleTouch(t) {
  const p = getPos(t);
  let px = ctx.getImageData(p.x,p.y,1,1).data;
  currentColor = { r:px[0], g:px[1], b:px[2] };

  // Aplicar calibración si existe
  if(blackPoint && whitePoint){
    currentColor = applyCalibration(currentColor);
  }

  loupe.style.display = 'block';
  loupe.style.left = p.sx+15+'px';
  loupe.style.top = p.sy-110+'px';

  loupeCtx.imageSmoothingEnabled=false;
  loupeCtx.clearRect(0,0,100,100);
  loupeCtx.drawImage(canvas,p.x-8,p.y-8,16,16,0,0,100,100);

  pickerBox.style.display='block';
  pickerBox.style.left = p.sx + 15 + 'px';
  pickerBox.style.top = p.sy + 'px';
  colorPreview.style.background = rgbToHex(currentColor);

  // Limpiar inputs al tocar nuevo color
  colorNumber.value = '';
  colorName.value = '';
}

/* ========= CALIBRATION FUNCTION ========= */
function applyCalibration(c){
  const scale = {
    r: 255/(whitePoint.r - blackPoint.r || 1),
    g: 255/(whitePoint.g - blackPoint.g || 1),
    b: 255/(whitePoint.b - blackPoint.b || 1)
  };
  return {
    r: clamp((c.r - blackPoint.r) * scale.r),
    g: clamp((c.g - blackPoint.g) * scale.g),
    b: clamp((c.b - blackPoint.b) * scale.b)
  };
}
function clamp(v){ return Math.min(255, Math.max(0, Math.round(v))); }

/* ========= SAVE COLOR ========= */
function saveColor() {
  if (!currentCollection) return alert('Crea una colección');
  const n = colorNumber.value;
  const name = colorName.value;
  const hsl = rgbToHsl(currentColor);
  data[currentCollection].push({ n, name, ...currentColor, ...hsl });
  saveData();
  renderGrid();
  pickerBox.style.display='none';
}

/* ========= GRID ========= */
function renderGrid() {
  const g = document.getElementById('colorGrid');
  g.innerHTML='';
  (data[currentCollection]||[]).forEach((c,i)=>{
    const d=document.createElement('div');
    d.className='colorCell';
    d.innerHTML=`
      <div class="removeBtn" onclick="removeColor(${i})">×</div>
      <div class="colorSwatch" style="background:${rgbToHex(c)}"></div>
      ${c.n}<br>${c.name}
    `;
    d.onclick=()=>generatePalettes(c);
    g.appendChild(d);
  });
}

function removeColor(i){
  data[currentCollection].splice(i,1);
  saveData(); renderGrid();
}

/* ========= SORT ========= */
function sortBy(k){
  data[currentCollection].sort((a,b)=>a[k]-b[k]);
  saveData(); renderGrid();
}

/* ========= PALETTES ========= */
function generatePalettes(base){
  alert('Aquí se generarían 5 paletas combinando colores de la colección.\n(Siguiente iteración las mostramos visualmente)');
}

/* ========= EXPORT ========= */
function exportNumbers(){
  const txt=data[currentCollection].map(c=>c.n).join(', ');
  alert(txt);
}

/* ========= UTILS ========= */
function saveData(){
  localStorage.setItem('chromaData',JSON.stringify(data));
}
function rgbToHex(c){
  return '#'+[c.r,c.g,c.b].map(v=>v.toString(16).padStart(2,'0')).join('');
}
function rgbToHsl({r,g,b}){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h,s,l=(max+min)/2;
  if(max===min){h=s=0;}
  else{
    const d=max-min;
    s=l>0.5?d/(2-max-min):d/(max+min);
    switch(max){
      case r:h=(g-b)/d+(g<b?6:0);break;
      case g:h=(b-r)/d+2;break;
      case b:h=(r-g)/d+4;break;
    }
    h/=6;
  }
  return {h:h*360,s:s*100,l:l*100};
}

/* INIT */
refreshCollections();
renderGrid();
</script>

</body>
</html>
